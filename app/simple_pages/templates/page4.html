{% extends "base.html" %}
{% block content %}

    <body>

    <div class="container">

        <div class="row">
            <header class="mb-5">
                <nav class="navbar navbar-light bg-light">
                    <div class="container-fluid">
                        <a class="navbar-brand" href="#">SOLID in details</a>
                        <ul class="navbar-nav">
                            <li class="nav-item">
                                <a class="nav-link" aria-current="page" href="/">Home</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link active" aria-current="page" href="/page4">Page 4</a>
                            </li>
                        </ul>
                    </div>
                </nav>
            </header>
            <div class="row"


            <div class="row">
                <h1><span class="diffont">S</span>OLID</h1>
            </div>

            <div class="col-14">


                 <p>

               <img src="{{ url_for('static', filename='images/solid1.png') }}" class="img-fluid mt-5"
                  alt="staticmethod" width="600px" height="500px"style="float:right">


               </p>

                <p>
                    S - single-responsibility principle - is when a function does one action and that is what it is
                    responsible for, period!
                </p>
                <p>
                    O - open-closed principle - its a situation when if you look at a function and you make sure that function
                    does what it meant to do to work properly and there are no any other way to improve it, and if there is
                    you must include an exception to close it. To summarize it, with the open-closed principle functions and
                    classes will be open for extensions and closed for any modification.
                </p>
                <p>
                    L - Liskov substitute principle - is when you are able to substitute child and parent classes together.
                    For example, lets say we have class C which is a child class for class B, class B can easily replace
                    class B without damaging code/program.
                </p>
                <p>
                    I - interface segregation principle - is when classes will do one and only thing. In our case we have a
                    calculator class where we do not want it to depend on methods that it will not use and split larger
                    features into smaller departments.
                </p>
                <p>
                    D - Dependency inversion principle - is when functions will call on each other
                    Calculator test in this case will call for let's say a subtraction method creating independent function
                    in the calculator and being independent of each other. Overall, higher level modules will not depend on
                    lower once where at the end of the day they will both depend on abstractions.
                </p>

                <h2><u>Whats a design method in programming and what do we need to use it for?</u></h2>
                The whole purpose of the design pattern is to have an established set of rules that will standardise our way of
                writing a code. A programmist can freely express creativity in their work and all but at the end of the day we
                want to have some type of standard,
                which will make reading a code much easier and establish certain criteria in the industry. A great
                example of
                that will be driving. Everyone has a different style of driving but at the end of the day we have to
                follow
                the state motor vehicle commission driving rules. ADD more from resources


                </p>
                <p>
                    <h2><u>How is factory method involved with the object-oriented programming?</u></h2>
                    Factory method - is a method that is a part of the design pattern. WIth this type of method you would
                    return back an instance of a class that you were referring to. You want to start with a factory pattern
                    first and as you build your skill, its benefician to introduce other design patterns like structural and
                    behavioral patterns. An interesting fact: single responsability will trigger the factory method! ADD more from sources
                </p>

            </div>

                <p>
                    <h2><u>Sources:</u></h2>
                </p>

                <p>
                    https://towardsdatascience.com/solid-coding-in-python-1281392a6a94
                    https://www.dckap.com/blog/why-should-every-developer-follow-solid-principles/
                    https://faun.pub/solid-software-design-3d2d80a3838a
                </p>

            </div>
        </div>

    </div>

    <!-- Optional JavaScript; choose one of the two! -->

    <!-- Option 1: Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
            crossorigin="anonymous"></script>

    <!-- Option 2: Separate Popper and Bootstrap JS -->
    <!--
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    -->

    <script src="{{ url_for('static', filename='js/scripts.js') }}"></script>

    </body>
    </html>
{% endblock %}